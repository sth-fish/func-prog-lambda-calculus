### Recursive function constructor

```
def recursive f = λs.(f (s s)) λs.(f (s s))
```

### Addition

```
def add_aux f x y =
    if is_zero y
    then x
    else (f (succ x) (pred y))

def add = recursive add_aux
```

```
add one two ==
(λf.(λs.(f (s s)) λs.(f (s s))) add_aux) one two =>
(λs.(add_aux (s s)) λs.(add_aux (s s))) one two =>
(add_aux (λs.(add_aux (s s)) λs.(add_aux (s s)))) one two ==
(λf.λx.λy.
    if is_zero y
    then x
    else (f (succ x) (pred y)) (λs.(add_aux (s s)) λs.(add_aux (s s)))) one two =>
λx.λy.
    if is_zero y
    then x
    else ((λs.(add_aux (s s)) λs.(add_aux (s s))) (succ x) (pred y)) one two => ... =>
if is_zero two
then one
else ((λs.(add_aux (s s)) λs.(add_aux (s s))) (succ one) (pred two)) => ... =>
((add_aux (λs.(add_aux (s s)) λs.(add_aux (s s)))) (succ one) (pred two)) ==
((λf.λx.λy.
    if is_zero y
    then x
    else (f (succ x) (pred y)) (λs.(add_aux (s s)) λs.(add_aux (s s)))) (succ one) (pred two)) => ... =>
if is_zero (pred two)
then (succ one)
else ((λs.(add_aux (s s)) λs.(add_aux (s s))) (succ (succ one)) (pred (pred two))) => ... =>
((add_aux (λs.(add_aux (s s)) λs.(add_aux (s s)))) (succ (succ one)) (pred (pred two))) ==
((λf.λx.λy.
    if is_zero y
    then x
    else (f (succ x) (pred y)) (λs.(add_aux (s s)) λs.(add_aux (s s)))) (succ (succ one)) (pred (pred two))) =>
(λx.λy.
    if is_zero y
    then x
    else ((λs.(add_aux (s s)) λs.(add_aux (s s))) (succ x) (pred y)) (succ (succ one)) (pred (pred two))) => ... =>
if is_zero (pred (pred two))
    then (succ (succ one))
    else ((λs.(add_aux (s s)) λs.(add_aux (s s))) (succ (succ (succ one))) (pred (pred (pred two)))) => ... =>
(succ (succ one)) ==
three
```

### Recursive notation: paradoxical combinator Y

```
rec <name> = <expression>
```

is replaced by:

```
def <name1> f = ... (f f ...) ...
def <name> = recursive <name1>
```

### Arithmetics operations

```
rec add x y =
    if is_zero y
    then x
    else add (succ x) (pred y)
```

```
rec mult x y =
    if is_zero y
    then zero
    else add x (mult x (pred y))
```

```
rec power x y =
    if is_zero y
    then one
    else mult x (power x (pred y))
```

```
rec sub x y =
    if is_zero y
    return x
    else sub (pred x) (pred y)
```

```
def abs_diff x y = add (sub x y) (sub y x)
```

```
def equal x y = is_zero (abs_diff x y)
```

```
def greater x y = not (is_zero (sub x y))
```

```
def greater_or_equal x y = is_zero (sub y x)
```

```
rec div x y =
    if is_zero y
    then zero
    else if greater y x
            then zero
            else succ (div (sub x y) y)
```