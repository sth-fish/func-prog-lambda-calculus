#### Truth values and conditional expressions

```
def select_first = λfirst.λsecond.first
def select_second = λfirst.λsecond.second
def true = select_first
def false = select_second
def cond = λe1.λe2.λc.((c e1) e2)
```

### NOT

| p | ⌐p  |
| - | :-: |
| T |  F  |
| F |  T  |

```
def not = λx.(((cond false) true) x)
```

body simplification

```
(((λe1.λe2.λc.((c e1) e2) false) true) x) =>
((λe2.λc.((c false) e2) true) x) =>
(λc.((c false) true) x) => 
((x false) true)
```

gives

```
def not = λx.((x false) true)
```

¬ TRUE ≡ FALSE

```
(not true) ==
(λx.((x false) true) true) =>
((true false) true) ==
((λfirst.λsecond.first false) true) =>
(λsecond.false true) =>
false
```

¬ FALSE ≡ TRUE

```
(not false) ==
(λx.((x false) true) false) =>
((false false) true) ==
((λfirst.λsecond.second false) true) =>
(λsecond.second true) =>
true
```

### AND

| p | q | p ∧ q |
| - | - | :---: |
| F | F |   F   |
| F | T |   F   |
| T | F |   F   |
| T | T |   T   |

```
def and = λx.λy.(((cond y) false) x)
```

body simplification

```
(((λe1.λe2.λc.((c e1) e2) y) false) x) =>
((λe2.λc.((c y) e2) false) x) =>
(λc.((c y) false) x) =>
((x y) false)
```

gives

```
def and = λx.λy.((x y) false)
```

FALSE ∧ FALSE ≡ FALSE

```
((and false) false) ==
((λx.λy.((x y) false) false) false) =>
(λy.((false y) false) false) =>
((false false) false) ==
((λfirst.λsecond.second false) false) =>
(λsecond.second false) =>
false
```

FALSE ∧ TRUE ≡ FALSE

```
((and false) true) ==
((λx.λy.((x y) false) false) true) =>
(λy.((false y) false) true) =>
((false true) false) ==
((λfirst.λsecond.second true) false) =>
(λsecond.second false) =>
false
```

TRUE ∧ FALSE ≡ FALSE

```
((and true) false) ==
((λx.λy.((x y) false) true) false) =>
(λy.((true y) false) false) =>
((true false) false) ==
((λfirst.λsecond.first false) false) =>
(λsecond.false false) =>
false
```

TRUE ∧ TRUE ≡ TRUE

```
((and true) true) ==
((λx.λy.((x y) false) true) true) =>
(λy.((true y) false) true) =>
((true true) false) ==
((λfirst.λsecond.first true) false) =>
(λsecond.true false) =>
true
```

### OR

| p | q | p ∨ q |
| - | - | :---: |
| F | F |   F   |
| F | T |   T   |
| T | F |   T   |
| T | T |   T   |

```
def or = λp.λq.(((cond true) p) q)
```

body simplification

```
(((cond true) p) q) ==
(((λe1.λe2.λc.((c e1) e2) true) p) q) =>
((λe2.λc.((c true) e2) p) q) =>
(λc.((c true) p) q) =>
((q true) p)
```

gives

```
def or = λp.λq.((q true) p)
```

FALSE ∨ FALSE ≡ FALSE

```
((or false) false) ==
((λp.λq.((q true) p) false) false) =>
(λq.((q true) false) false) =>
((false true) false) ==
((λfirst.λsecond.second true) false) =>
(λsecond.second false) =>
false
```

FALSE ∨ TRUE ≡ TRUE

```
((or false) true) ==
((λp.λq.((q true) p) false) true) =>
(λq.((q true) false) true) =>
((true true) false) ==
((λfirst.λsecond.first true) false) =>
(λsecond.true false) =>
true
```

TRUE ∨ FALSE ≡ TRUE

```
((or true) false) ==
((λp.λq.((q true) p) true) false) =>
(λq.((q true) true) false) =>
((false true) true) ==
((λfirst.λsecond.second true) true) =>
(λsecond.second true) =>
true
```

TRUE ∨ TRUE ≡ TRUE

```
((or true) true) ==
((λp.λq.((q true) p) true) true) =>
(λq.((q true) true) true) =>
((true true) true) ==
((λfirst.λsecond.first true) true) =>
(λsecond.true true) =>
true
```

### Natural numbers

```
def zero = identity
def succ = λn.λs.((s false) n)
```

```
def one = (succ zero)
def two = (succ one)
def three = (succ two)
```

```
def is_zero = λn.(n select_first)
```

```
(is_zero one) ==
(λn.(n select_first) one) =>
(one select_first) ==
((succ zero) select_first) ==
((λn.λs.((s false) n) zero) select_first) =>
(λs.((s false) zero) select_first) =>
((select_first false) zero) ==
((λfirst.λsecond.first false) zero) =>
(λsecond.false zero) =>
false
```

```
(is_zero zero) ==
(λn.(n select_first) zero) =>
(zero select_first) ==
(identity select_first) ==
(λx.x select_first) =>
select_first ==
true
```