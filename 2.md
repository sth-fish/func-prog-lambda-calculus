### λ calculus syntax

```
<expression> ::= <name> | <function> | <application>

<name> ::= non-blank chars sequence

<function> ::= λ<name>.<body>

<body> ::= <expression>

<application> ::= (<function expression> <argument expression>)

<function expression> ::= <expression>

<argument expression> ::= <expression>
```

#### 2.1: λ expression structure

```
λa.(a λb.(b a))
  <function> - λa.(a λb.(b a))
    <bound variable> - a
    <body> - (a λb.(b a))
      <application> - (a λb.(b a))
        <function expression> - a
          <name> - a
        <argument expression> - λb.(b a)
          <function> - λb.(b a)
            <bound variable> - b
            <body> - (b a)
              <application> - (b a)
                <function expression> - b
                  <name> - b
                <argument expression> - a
                  <name> - a
```

```
λx.λy.λz.((z x) (z y))
  <function> - λx.λy.λz.((z x) (z y))
    <bound variable> - x
    <body> - λy.λz.((z x) (z y))
      <function>
        <bound variable> - y
        <body> - λz.((z x) (z y))
          <function> - λz.((z x) (z y))
            <bound variable> - z
            <body> - ((z x) (z y))
              <application> - ((z x) (z y))
                <function expression> - (z x)
                  <application> - (z x)
                    <function expression> - z
                      <name> - z
                    <argument expression> - x
                      <name> - x
                <argument expression> - (z y)
                  <application> - (z y)
                    <function expression> - z
                      <name> - z
                    <argument expression> - y
                      <name> - y
```

```
(λf.λg.(λh.(g h) f) λp.λq.p)
  <application> - (λf.λg.(λh.(g h) f) λp.λq.p)
    <function expression> - λf.λg.(λh.(g h) f)
      <function> - λf.λg.(λh.(g h) f)
        <bound variable> - f
        <body> - λg.(λh.(g h) f)
          <function> - λg.(λh.(g h) f)
            <bound variable> - g
            <body> - (λh.(g h) f)
              <application> - (λh.(g h) f)
                <function expression> - λh.(g h)
                  <function> - λh.(g h)
                    <bound variable> - h
                    <body> - (g h)
                      <application> - (g h)
                        <function expression> - g
                          <name> - g
                        <argument expression> - h
                          <name> - h
                <argument expression> - f
                  <name> - f
    <argument expression> - λp.λq.p
      <function> - λp.λq.p
        <bound variable> - p
        <body> - λq.p
          <function> - λq.p
            <bound variable> - q
            <body> - p
              <name> - p
```

```
λfee.λfi.λfo.λfum.(fum (fo (fi fee)))
  <function> - λfee.λfi.λfo.λfum.(fum (fo (fi fee)))
    <bound variable> - fee
    <body> - λfi.λfo.λfum.(fum (fo (fi fee)))
      <function>
        <bound variable> - fi
        <body> - λfo.λfum.(fum (fo (fi fee)))
          <function> - λfo.λfum.(fum (fo (fi fee)))
            <bound variable> - fo
            <body> - λfum.(fum (fo (fi fee)))
              <function> - λfum.(fum (fo (fi fee)))
                <bound variable> - fum
                <body> - (fum (fo (fi fee)))
                  <application> - (fum (fo (fi fee)))
                    <function expression> - fum
                      <name> - fum
                    <body expression> - (fo (fi fee))
                      <application> - (fo (fi fee))
                        <function expression> - fo
                          <name> - fo
                        <body expression> - (fi fee)
                          <application> - (fi fee)
                            <function expression> - fi
                              <name> - fi
                            <body expression> - fee
                              <name> - fee
```

```
(λp.(λq.p λx.(x p)) λi.λj.(j i))
  <application>
    <func exp> - λp.(λq.p λx.(x p))
      <func> - λp.(λq.p λx.(x p))
        <bound variable> - p
        <body> - (λq.p λx.(x p))
          <application> - (λq.p λx.(x p))
            <func exp> - λq.p
              <func> - λq.p
                <bound variable> - q
                <body> - p
            <arg ext> - λx.(x p)
              <func>
                <bound variable> - x
                <body> - (x p)
                  <application> - (x p)
                    <func expression> - x
                      <name> - x
                    <arg exp> - p
                      <name> - p
  <arg exp> - λi.λj.(j i)
    <function>
      <bound variable> - i
      <body> - λj.(j i)
        <function> - λj.(j i)
          <bound variable> - j
          <body> - (j i)
            <application> - (j i)
              <func exp> - j
                <name> - j
              <arg exp> - i
                <name> - i
```

#### 2.2: λ expression evaluation

```
((λx.λy.(y x) λp.λq.p) λi.i) =>
(λy.(y λp.λq.p) λi.i) =>
(λi.i λp.λq.p) =>
λp.λq.p
```

```
(((λx.λy.λz.((x y) z) λf.λa.(f a)) λi.i) λj.j) =>
((λy.λz.((λf.λa.(f a) y) z) λi.i) λj.j) =>
(λz.((λf.λa.(f a) λi.i) z) λj.j) =>
((λf.λa.(f a) λi.i) λj.j) =>
(λa.(λi.i a) λj.j) =>
(λi.i λj.j) =>
λj.j
```

```
(λh.((λa.λf.(f a) h) h) λf.(f f)) =>
((λa.λf.(f a) λf.(f f)) λf.(f f)) =>
(λf.(f λf.(f f)) λf.(f f)) =>
(λf.(f f) λf.(f f)) =>
(λf.(f f) λf.(f f)) =>
... expression never terminates
```

```
((λp.λq.(p q) (λx.x λa.λb.a)) λk.k) =>
(λq.((λx.x λa.λb.a) q) λk.k) =>
((λx.x λa.λb.a) λk.k) =>
(λa.λb.a λk.k) =>
λb.λk.k
```

```
(((λf.λg.λx.(f (g x)) λs.(s s)) λa.λb.b) λx.λy.x) =>
((λg.λx.(λs.(s s) (g x)) λa.λb.b) λx.λy.x) =>
(λx.(λs.(s s) (λa.λb.b x)) λx.λy.x) =>
(λs.(s s) (λa.λb.b λx.λy.x)) =>
((λa.λb.b λx.λy.x) (λa.λb.b λx.λy.x)) =>
(λb.b (λa.λb.b λx.λy.x)) =>
(λa.λb.b λx.λy.x) =>
λb.b
```

#### 2.3: prove the function is equivalent function expression

identity and (apply (apply identity))

```
def identity = λx.x
def appy = λfunc.λarg.(func arg)

(identity <argument>) ==
(λx.x <argument>) =>
<argument>

((apply (apply identity)) <argument>) ==
((λfunc.λarg.(func arg) (apply identity)) <argument>) =>
(λarg.((apply identity) arg) <argument>) =>
((apply identity) <argument>) ==
((λfunc.λarg.(func arg) identity) <argument>) =>
(λarg.(identity arg) <argument>) =>
(identity <argument>) ==
(λx.x <argument>) =>
<argument>
```

apply and λx.λy.(((make_pair x) y) identity)

```
def identity = λx.x
def appy = λfunc.λarg.(func arg)
def make_pair = λfirst.λsecond.λfunc.((func first) second)

((apply <function>) <argument>) ==
((λfunc.λarg.(func arg) <function>) <argument>) =>
(λarg.(<function> arg) <argument>) =>
(<function> <argument>)

((λx.λy.(((make_pair x) y) identity) <function>) <argument>) =>
(λy.(((make_pair <function>) y) identity) <argument>) =>
(((make_pair <function>) <argument>) identity) ==
(((λfirst.λsecond.λfunc.((func first) second) <function>) <argument>) identity) =>
((λsecond.λfunc.((func <function>) second) <argument>) identity) =>
(λfunc.((func <function>) <argument>) identity) =>
((identity <function>) <argument>) ==
((λx.x <function>) <argument>) =>
(<function> <argument>)
```

identity and (self_apply (self_apply select_second))

```
def identity = λx.x
def select_second = λfirst.λsecond.second
def self_apply = λs.(s s)

(identity <argument>) ==
(λx.x <argument>) =>
<argument>

((self_apply (self_apply select_second)) <argument>) ==
((λs.(s s) (self_apply select_second)) <argument>) =>
(((self_apply select_second) (self_apply select_second)) <argument>) ==
(((λs.(s s) select_second) (self_apply select_second)) <argument>) =>
(((select_second select_second) (self_apply select_second)) <argument>) ==
(((λfirst.λsecond.second select_second) (self_apply select_second)) <argument>) =>
((λsecond.select_second (self_apply select_second)) <argument>) =>
((self_apply select_second) <argument>) ==
((λs.(s s) select_second) <argument>) =>
((select_second select_second) <argument>) ==
((λfirst.λsecond.second select_second) <argument>) =>
(λsecond.second <argument>) =>
<argument>
```